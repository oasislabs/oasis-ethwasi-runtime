syntax = "proto3";

package api;

message InitStateRequest {
    repeated AccountState accounts = 1;
}

message InitStateResponse {
}

// We have to use strings/bytes for everything since protobuf doesn't support wide enough integers (e.g., addresses
// in ethereum are 160-bit hashes). Encoded numerical values are annotated as (dec) or (hex).
message AccountState {
    string nonce = 1;                // (dec)
    string address = 2;              // (hex)
    string balance = 3;              // (dec)
    map<string, string> storage = 4;
    string code = 5;                 // (hex)
}

message AccountRequest {
    string address = 1;              // (hex)
}

message AccountBalanceResponse {
    string balance = 1;              // (dec)
}

message AccountNonceResponse {
    string nonce = 1;                // (dec)
}

message ReceiptRequest {
    string hash = 1;                 // (hex) transaction hash
}

message ReceiptResponse {
    Receipt receipt = 1;
}

message Receipt {
    string hash = 1;                // (hex) transaction hash
    string block_number = 2;        // (hex)
    uint32 index = 3;               // txn index in block, always 0 for single-txn blocks
    bool is_create = 4;             // is this a create transacation?
    string from = 5;                // (hex) sender address
    string to = 6;                  // (hex) receiver address, defined if !is_create
    string gas_used = 7;            // (hex) gas used to execute this txn
    string cumulative_gas_used = 8; // (hex) always equal to gas_used for single-txn blocks
    string contract_address = 9;    // (hex) address of created contract, defined if is_create
    bool status = 10;               // true for success
    // TODO: add logs
}

message Transaction {
    bool use_nonce = 1;
    string nonce = 2;               // (dec) optional
    string caller = 3;              // (hex)
    bool is_call = 4;
    string address = 5;             // (hex) defined if is_call = true
    string input = 6;               // (hex)
}

message ExecuteTransactionRequest {
    Transaction transaction = 1;
    bool simulate = 2;              // true for eth_call
}

message ExecuteRawTransactionRequest {
    string data = 1;                // (hex)
}

message Log {
    // TODO: add logs from VM
}

message ExecuteTransactionResponse {
    string request = 1;
    Log log = 2;
    string used_gas = 3;            // (hex)
    bool status = 4;                // ExitedOk => true
    string result = 5;              // (hex)
    string hash = 6;                // (hex) returned by sendTransaction and sendRawTransaction
}
