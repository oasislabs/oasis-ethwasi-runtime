syntax = "proto3";

package api;

message InjectAccountsRequest {
    repeated AccountState accounts = 1;
}

message InjectAccountsResponse {
}

message InitStateRequest {
}

message InitStateResponse {
}

// We have to use strings/bytes for everything since protobuf doesn't support wide enough integers (e.g., addresses
// in ethereum are 160-bit hashes). Encoded numerical values are annotated as (dec) or (hex).
message AccountState {
    string nonce = 1;                // (dec)
    string address = 2;              // (hex)
    string balance = 3;              // (dec)
    map<string, string> storage = 4;
    string code = 5;                 // (hex)
}

message AccountRequest {
    string address = 1;              // (hex)
}

message AccountBalanceResponse {
    string balance = 1;              // (dec)
}

message AccountNonceResponse {
    string nonce = 1;                // (dec)
}

message AccountCodeResponse {
    string code = 1;                 // (hex)
}

message TransactionRecordRequest {
    string hash = 1;                 // (hex) transaction hash
}

message TransactionRecordResponse {
    TransactionRecord record = 1;
}

message TransactionRecord {
    string hash = 1;                 // (hex) transaction hash
    string nonce = 2;                // (dec)
    string block_hash = 3;           // (hex)
    string block_number = 4;         // (hex)
    uint32 index = 5;                // txn index in block, always 0 for single-txn blocks
    bool is_create = 6;              // is this a create transacation?
    string from = 7;                 // (hex) sender address
    string to = 8;                   // (hex) receiver address, defined if !is_create
    string gas_used = 9;             // (hex) gas used to execute this txn
    string cumulative_gas_used = 10; // (hex) always equal to gas_used for single-txn blocks
    string contract_address = 11;    // (hex) address of created contract, defined if is_create
    string value = 12;               // (hex)
    string gas_price = 13;           // (hex)
    string gas_provided = 14;        // (hex)
    string input = 15;               // (hex)
    bool status = 16;                // true for success
    // TODO: add logs
}

message Block {
    string number = 1;               // (hex)
    string hash = 2;                 // (hex)
    string parent_hash = 3;          // (hex)
    string transaction_hash = 4;     // (hex)
    TransactionRecord transaction = 5;
}

message BlockRequest {
    string hash = 1;                 // (hex) block hash
    string number = 2;               // (hex) block number
    bool full = 3;                   // if true, return full transaction objects, otherwise hashes
}

message BlockResponse {
    Block block = 1;
}

// An unsigned transaction.
message Transaction {
    bool use_nonce = 1;
    // The nonce from web3. It's a monotonic counter per account.
    string nonce = 2;               // (dec) optional
    // The "from" addr.
    string caller = 3;              // (hex)
    // True if it's a call to a contract, with a "to" addr. If it's not a call, it's a "create."
    bool is_call = 4;
    // The "to" addr for a call to a contractx.
    string address = 5;             // (hex) defined if is_call = true
    // Opaque call input.
    string input = 6;               // (hex)
    string value = 7;               // (hex)
}

message ExecuteTransactionRequest {
    Transaction transaction = 1;
}

message ExecuteRawTransactionRequest {
    // A signed transaction (using Ethereum's own format).
    string data = 1;                // (hex)
}

message Log {
    // TODO: add logs from VM
}

message ExecuteTransactionResponse {
    string request = 1;
    Log log = 2;
    string used_gas = 3;            // (hex)
    bool status = 4;                // ExitedOk => true
    string result = 5;              // (hex)
    string hash = 6;                // (hex) returned by sendTransaction and sendRawTransaction
}
